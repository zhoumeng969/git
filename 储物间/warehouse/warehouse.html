<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <!-- <script>
        //vue的数据绑定利用Object.defineProperty中的getter和setter代理数据
        var obj = {};
        obj.a = 1;
        Object.defineProperty(obj,'b',{
           value : 10,
           writable : true, //设置写入权限
           enumerable : true,//设置遍历权限
           configurable :true ,//以上权限的配置权力
           get(){
               return 1000
           }   //读操作getter函数
           set(){
               return 2000
           }   //写操作setter函数
        })    
        obj.b = 32
        console.log(obj.b)
        for(var item in obj){
            console.log(item)
        }
    </script>           -->







    <!-- <div>
            <div>
                <div></div>
            </div>
        </div>
        <script>
            var obj = {
                childNodes:{
                    div:{
                        childNodes:{
                            div:{
                                childNodes:{
    
                                }
                            }
                        }
                    }
                }
            }
            用js模拟html，刷新最小dom节点，而不刷新整个dom节点 
        </script> -->





            <!-- <script> 
                h("div",{class:"demo",id:"demo1"},["hello word","h1",
                h("p",{class:demo2},["我是p标签"])]).render()
                h函数内用div标签，class属性叫demo有一个id属性叫demo1，然后有一个子节点hello word，第二个子节点叫h1 ，
                通过调用h函数创造一个p标签，里面有一个对象，对象内有一个class叫demo2 p标签里有一个子节点是一个数组是我叫p标签
                调用.render()函数，就可以转换为真实的dom节点
            </script> 
              效果
            <div class="demo" id="demo1">
                hello wordh1
                <p class="demo2">
                    我是p标签
                </p>
                这就是利用虚拟dom构建出来的节点
                由此产生了数据的双向绑定
            </div>   -->
</body>
</html> 